åŸºäº**0G DeAIåŸºç¡€è®¾æ–½**å’Œ**å•å±‚æ¶æ„åŸåˆ™**ï¼Œé‡æ„MEMEå¸é€‰å¸å¹³å°ï¼Œå®ç°**å»ä¸­å¿ƒåŒ–AIæ¨ç† + é“¾ä¸Šå¯éªŒè¯å­˜å‚¨ + å•å±‚TypeScriptå…¨æ ˆ**ã€‚

---

## ä¸€ã€0G DeAIæ¶æ„æ ¸å¿ƒè®¾è®¡

### 1.1 æ¶æ„èŒƒå¼ï¼šå•å±‚DeAIï¼ˆSingle-Tier DeAIï¼‰
**ç¦æ­¢å¾®æœåŠ¡æ‹†åˆ†**ï¼Œæ‰€æœ‰0Gäº¤äº’åœ¨Next.js Edge Functionä¸­åŸå­å®Œæˆï¼š

```typescript
// æ¶æ„æ‹“æ‰‘
User Request â†’ Next.js API Route (Vercel Edge)
                    â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â†“               â†“               â†“
0G Compute    0G Storage      0G Chain
(DeAIæ¨ç†)    (å¯ä¿¡å­˜å‚¨)      (åˆçº¦éªŒè¯)
    â†“               â†“               â†“
æ¨ç†ç»“æœ + Merkle Root â†’ é“¾ä¸Šå­˜è¯ â† å®¡è®¡åˆçº¦
```

### 1.2 èŒè´£åˆ†å·¥ï¼ˆ0Gå››åˆä¸€ï¼‰
| 0Gç»„ä»¶ | èŒèƒ½ | MEMEé€‰å¸åœºæ™¯åº”ç”¨ |
|-------|------|----------------|
| **0G Compute** | å»ä¸­å¿ƒåŒ–AIæ¨ç† | æƒ…ç»ªåˆ†æã€é€‰å¸ä¿¡å·ç”Ÿæˆï¼ˆæ›¿ä»£ä¸­å¿ƒåŒ–OpenAI APIï¼‰ |
| **0G Storage** | ä¸å¯å˜å®¡è®¡æ—¥å¿— | ç­–ç•¥å¿«ç…§ã€å› å­æ•°æ®ã€äº¤æ˜“è®°å½•æ°¸ä¹…å­˜å‚¨ |
| **0G Chain** | æ™ºèƒ½åˆçº¦éªŒè¯ | éªŒè¯æ¨ç†ç»“æœçœŸå®æ€§ã€æ‰§è¡Œæ”¶ç›Šåˆ†æˆ |
| **0G DA** | æ•°æ®å¯ç”¨æ€§ï¼ˆå¯é€‰ï¼‰ | é«˜é¢‘ç­–ç•¥æ•°æ®çš„ä¸´æ—¶å¯ç”¨æ€§ä¿éšœ |

---

## äºŒã€æ ¸å¿ƒå®ç°æ–¹æ¡ˆ

### 2.1 é¡¹ç›®ç»“æ„ï¼ˆ0G Nativeï¼‰
```typescript
strattrust-deai/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”œâ”€â”€ ai/
â”‚   â”‚   â”‚   â””â”€â”€ infer/route.ts          # 0G Compute DeAIæ¨ç†
â”‚   â”‚   â”œâ”€â”€ storage/
â”‚   â”‚   â”‚   â”œâ”€â”€ upload/route.ts         # ç­–ç•¥å¿«ç…§ä¸Šé“¾
â”‚   â”‚   â”‚   â””â”€â”€ verify/route.ts         # MerkleéªŒè¯
â”‚   â”‚   â””â”€â”€ execute/
â”‚   â”‚       â””â”€â”€ route.ts                # 0G Chainåˆçº¦äº¤äº’
â”‚   â””â”€â”€ (app)/...                       # é¡µé¢ç»„ä»¶
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ 0g/
â”‚   â”‚   â”œâ”€â”€ compute.ts                  # 0G Serving Brokerå°è£…
â”‚   â”‚   â”œâ”€â”€ storage.ts                  # 0G Storage SDKå°è£…
â”‚   â”‚   â””â”€â”€ chain.ts                    # 0G Chainåˆçº¦äº¤äº’
â”‚   â””â”€â”€ ai-logic.ts                     # é€‰å¸é€»è¾‘ï¼ˆçº¯TSï¼‰
â”œâ”€â”€ contracts/
â”‚   â””â”€â”€ AuditVerifier.sol               # éªŒè¯æ¨ç†ç»“æœçš„åˆçº¦
â”œâ”€â”€ prisma/
â”‚   â””â”€â”€ schema.prisma                   # æœ¬åœ°ç´¢å¼•ï¼ˆå…ƒæ•°æ®ç¼“å­˜ï¼‰
â””â”€â”€ .env
    â”œâ”€â”€ ZEROG_RPC_URL=https://evmrpc-testnet.0g.ai
    â”œâ”€â”€ ZEROG_INDEXER=https://indexer-storage-testnet-turbo.0g.ai
    â””â”€â”€ PRIVATE_KEY=0x...
```

### 2.2 0G Computeé›†æˆï¼ˆDeAIæ¨ç†ï¼‰

**æ›¿ä»£æ–¹æ¡ˆ**ï¼šä¸å†ç›´æ¥è°ƒç”¨OpenAI APIï¼Œè€Œæ˜¯é€šè¿‡0G Compute Brokerè°ƒç”¨å»ä¸­å¿ƒåŒ–AIç½‘ç»œï¼ˆDeepSeek/GPT-OSSç­‰ï¼‰ï¼Œå®ç°**æŠ—å®¡æŸ¥**å’Œ**å¯éªŒè¯æ¨ç†**ã€‚

```typescript
// lib/0g/compute.ts
import { createZGComputeNetworkBroker } from '@0glabs/0g-serving-broker';
import { ethers } from 'ethers';
import { z } from 'zod';

// ä¿¡å·è¾“å‡ºSchemaï¼ˆä¸¥æ ¼ç±»å‹å®‰å…¨ï¼‰
const MemeSignalSchema = z.object({
  symbol: z.string(),
  action: z.enum(['BUY', 'SELL', 'HOLD']),
  confidence: z.number().min(0).max(1),
  sentiment_score: z.number(),
  factors: z.array(z.object({
    name: z.string(),
    value: z.number(),
    weight: z.number()
  })),
  timestamp: z.number(),
  nonce: z.string()
});

export class DeAIInference {
  private broker: any;
  private signer: ethers.Wallet;
  
  constructor(privateKey: string, rpcUrl: string) {
    const provider = new ethers.JsonRpcProvider(rpcUrl);
    this.signer = new ethers.Wallet(privateKey, provider);
  }

  async initialize() {
    // åˆå§‹åŒ–0G Compute Brokerï¼ˆå»ä¸­å¿ƒåŒ–AIå¸‚åœºï¼‰
    this.broker = await createZGComputeNetworkBroker(this.signer);
  }

  // DeAIæ¨ç†ï¼šè°ƒç”¨0Gç½‘ç»œä¸­çš„AIæœåŠ¡ï¼ˆå¦‚DeepSeek V3ï¼‰
  async generateSignal(factorData: any): Promise<{
    signal: z.infer<typeof MemeSignalSchema>;
    requestId: string;
    provider: string;
    teeAttestation?: string;  // TEEå¯ä¿¡æ‰§è¡Œè¯æ˜
  }> {
    // 1. å‘ç°å¯ç”¨çš„AIæœåŠ¡æä¾›è€…
    const services = await this.broker.inference.listServices();
    const provider = services[0].provider; // é€‰æ‹©ç¬¬ä¸€ä¸ªå¯ç”¨æœåŠ¡
    
    // 2. ç¡®è®¤æœåŠ¡æä¾›è€…ï¼ˆå»ºç«‹å¾®æ”¯ä»˜é€šé“ï¼‰
    await this.broker.inference.acknowledgeProviderSigner(provider);
    
    // 3. æ„å»ºæç¤ºè¯ï¼ˆMEMEé€‰å¸ä¸“ç”¨ï¼‰
    const prompt = this.buildMemePrompt(factorData);
    
    // 4. è·å–è¯·æ±‚å¤´ï¼ˆå«ç­¾åå’Œæ”¯ä»˜å‡­è¯ï¼‰
    const headers = await this.broker.inference.getRequestHeaders(
      provider,
      'meme-analysis',
      prompt
    );
    
    // 5. å‘é€æ¨ç†è¯·æ±‚åˆ°0Gå»ä¸­å¿ƒåŒ–ç½‘ç»œ
    const response = await fetch(services[0].url, {
      method: 'POST',
      headers: { ...headers, 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model: 'deepseek-v3',  // æˆ– 'gpt-oss', 'gemma'
        messages: [
          { role: 'system', content: 'ä½ æ˜¯MEMEå¸é‡åŒ–åˆ†æä¸“å®¶ï¼Œè¿”å›ä¸¥æ ¼JSONæ ¼å¼' },
          { role: 'user', content: prompt }
        ],
        response_format: { type: 'json_object' }
      })
    });
    
    const result = await response.json();
    
    // 6. éªŒè¯å“åº”çœŸå®æ€§ï¼ˆ0G Computeè‡ªåŠ¨å¤„ç†æ”¯ä»˜å’ŒéªŒè¯ï¼‰
    const isValid = await this.broker.inference.processResponse(result.id);
    if (!isValid) throw new Error('AIæ¨ç†ç»“æœéªŒè¯å¤±è´¥');
    
    // 7. Zodæ ¡éªŒï¼ˆé˜²æ­¢æ¨¡å‹å¹»è§‰ï¼‰
    const signal = MemeSignalSchema.parse(JSON.parse(result.choices[0].message.content));
    
    return {
      signal,
      requestId: result.id,
      provider: provider,
      teeAttestation: result.attestation  // TEEæ‰§è¡Œè¯æ˜ï¼ˆå¦‚å¯ç”¨ï¼‰
    };
  }

  private buildMemePrompt(data: any): string {
    return `åŸºäºä»¥ä¸‹å› å­ç”ŸæˆMEMEå¸äº¤æ˜“ä¿¡å·ï¼š
- è®¢å•æµä¸å¹³è¡¡(OIF): ${data.oif}
- ç¤¾äº¤æƒ…ç»ªé€Ÿåº¦: ${data.sentiment_velocity}
- é“¾ä¸Šèªæ˜é’±æµå…¥: ${data.smart_money}
- æµåŠ¨æ€§æ·±åº¦: ${data.liquidity}
è¦æ±‚ï¼šè¾“å‡ºJSONæ ¼å¼ï¼ŒåŒ…å«symbol, action, confidence, reasoning`;
  }
}
```

### 2.3 0G Storageé›†æˆï¼ˆå¯ä¿¡å®¡è®¡ï¼‰

**å…³é”®åˆ›æ–°**ï¼šæ‰€æœ‰ç­–ç•¥å†³ç­–çš„**è¾“å…¥æŒ‡çº¹**å’Œ**è¾“å‡ºç»“æœ**ä¸Šä¼ åˆ°0G Storageï¼Œç”Ÿæˆ**Merkle Root**ä½œä¸ºä¸å¯ç¯¡æ”¹çš„è¯æ®ï¼Œè€Œéå­˜å‚¨åœ¨ä¸­å¿ƒåŒ–æ•°æ®åº“ã€‚

```typescript
// lib/0g/storage.ts
import { ZgFile, Indexer } from '@0glabs/0g-ts-sdk';
import { ethers } from 'ethers';
import { createHash } from 'crypto';

export class TrustStorage {
  private indexer: Indexer;
  private signer: ethers.Wallet;
  
  constructor(privateKey: string, rpcUrl: string, indexerUrl: string) {
    const provider = new ethers.JsonRpcProvider(rpcUrl);
    this.signer = new ethers.Wallet(privateKey, provider);
    this.indexer = new Indexer(indexerUrl);
  }

  // ç­–ç•¥å¿«ç…§ä¸Šä¼ ï¼ˆå…³é”®å®¡è®¡æ•°æ®ï¼‰
  async uploadStrategyEvidence(data: {
    signal: any;           // AIæ¨ç†ä¿¡å·
    inputHash: string;     // è¾“å…¥å› å­å“ˆå¸Œ
    modelVersion: string;  // æ¨¡å‹ç‰ˆæœ¬
    timestamp: number;
    teeAttestation?: string;
  }): Promise<{ rootHash: string; txHash: string }> {
    
    // 1. æ„å»ºç´§å‡‘çš„å®¡è®¡JSONï¼ˆæœ€å°è¯æ®é›†ï¼‰
    const evidence = {
      trace_id: this.generateTraceId(),
      input_hash: data.inputHash,
      model_ver: data.modelVersion,
      signal: {
        symbol: data.signal.symbol,
        action: data.signal.action,
        confidence: data.signal.confidence,
        factors_hash: this.hashObject(data.signal.factors)
      },
      timestamp: data.timestamp,
      tee_attestation: data.teeAttestation || null
    };
    
    // 2. å†™å…¥ä¸´æ—¶æ–‡ä»¶ï¼ˆNext.js /tmpç›®å½•ï¼‰
    const fs = require('fs');
    const tmpPath = `/tmp/evidence_${evidence.trace_id}.json`;
    fs.writeFileSync(tmpPath, JSON.stringify(evidence));
    
    // 3. åˆ›å»º0G Fileå¯¹è±¡å¹¶è®¡ç®—Merkle Tree
    const file = await ZgFile.fromFilePath(tmpPath);
    const [tree, err] = await file.merkleTree();
    if (err) throw new Error(`Merkleè®¡ç®—å¤±è´¥: ${err}`);
    
    const rootHash = tree.rootHash();
    
    // 4. ä¸Šä¼ åˆ°0G Storageï¼ˆå»ä¸­å¿ƒåŒ–å­˜å‚¨ï¼‰
    const [tx, uploadErr] = await this.indexer.upload(
      file,
      process.env.ZEROG_RPC_URL!,
      this.signer
    );
    
    if (uploadErr) throw new Error(`ä¸Šä¼ å¤±è´¥: ${uploadErr}`);
    
    await file.close();
    fs.unlinkSync(tmpPath);  // æ¸…ç†ä¸´æ—¶æ–‡ä»¶
    
    return {
      rootHash: rootHash,
      txHash: tx
    };
  }

  // æ‰¹é‡å®¡è®¡ï¼ˆæˆæœ¬ä¼˜åŒ–ï¼šå¤šæ¡è®°å½•æ‰“åŒ…ï¼‰
  async batchUploadEvidence(evidences: any[]): Promise<{ 
    rootHash: string; 
    batchSize: number;
  }> {
    // ä½¿ç”¨Merkle Treeæ±‡æ€»å¤šæ¡è¯æ®
    const batch = {
      batch_time: Date.now(),
      count: evidences.length,
      items: evidences,
      merkle_root: this.calculateBatchRoot(evidences)
    };
    
    return this.uploadStrategyEvidence(batch);
  }

  // éªŒè¯å­˜å‚¨æ•°æ®å®Œæ•´æ€§
  async verifyEvidence(rootHash: string, expectedData: any): Promise<boolean> {
    // ä¸‹è½½å¹¶éªŒè¯Merkle Proof
    const tmpPath = `/tmp/verify_${Date.now()}.json`;
    const err = await this.indexer.download(rootHash, tmpPath, true); // true=éªŒè¯æ•°æ®
    
    if (err) return false;
    
    const fs = require('fs');
    const data = JSON.parse(fs.readFileSync(tmpPath));
    fs.unlinkSync(tmpPath);
    
    return data.input_hash === expectedData.inputHash;
  }

  private generateTraceId(): string {
    return `st_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private hashObject(obj: any): string {
    return createHash('sha256').update(JSON.stringify(obj)).digest('hex');
  }

  private calculateBatchRoot(items: any[]): string {
    // ç®€åŒ–ç‰ˆMerkle Rootè®¡ç®—ï¼ˆå®é™…ä½¿ç”¨0G SDKçš„treeæ–¹æ³•ï¼‰
    const hashes = items.map(i => this.hashObject(i));
    return createHash('sha256').update(hashes.join('')).digest('hex');
  }
}
```

### 2.4 0G Chainåˆçº¦ï¼ˆéªŒè¯å±‚ï¼‰

**æ™ºèƒ½åˆçº¦**è´Ÿè´£éªŒè¯æ¨ç†ç»“æœçš„0G Storageè¯æ˜å’ŒTEEç­¾åï¼Œå®ç°**é“¾ä¸Šå¯éªŒè¯æ€§**ã€‚

```solidity
// contracts/AuditVerifier.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

contract StratTrustVerifier {
    // éªŒè¯äº‹ä»¶
    event SignalVerified(
        bytes32 indexed traceId,
        bytes32 inputHash,
        string action,
        uint256 confidence,
        bytes32 storageRoot,
        uint256 timestamp
    );
    
    // å·²éªŒè¯çš„ç­–ç•¥ä¿¡å·
    struct VerifiedSignal {
        bytes32 inputHash;
        bytes32 storageRoot;  // 0G Storage Merkle Root
        string action;
        uint256 confidence;
        uint256 timestamp;
        bool valid;
    }
    
    mapping(bytes32 => VerifiedSignal) public signals;
    address public owner;
    
    constructor() {
        owner = msg.sender;
    }
    
    // éªŒè¯å¹¶è®°å½•AIæ¨ç†ä¿¡å·
    function verifySignal(
        bytes32 _traceId,
        bytes32 _inputHash,
        string memory _action,
        uint256 _confidence,
        bytes32 _storageRoot,  // 0G Storageçš„Root Hash
        bytes memory _teeSig   // TEEç­¾åï¼ˆå¯é€‰ï¼‰
    ) external {
        // éªŒè¯TEEç­¾åï¼ˆå¦‚æä¾›ï¼‰
        if (_teeSig.length > 0) {
            require(verifyTEESignature(_inputHash, _teeSig), "Invalid TEE sig");
        }
        
        // è®°å½•éªŒè¯ç»“æœ
        signals[_traceId] = VerifiedSignal({
            inputHash: _inputHash,
            storageRoot: _storageRoot,
            action: _action,
            confidence: _confidence,
            timestamp: block.timestamp,
            valid: true
        });
        
        emit SignalVerified(
            _traceId,
            _inputHash,
            _action,
            _confidence,
            _storageRoot,
            block.timestamp
        );
    }
    
    // éªŒè¯TEEç­¾åï¼ˆç®€åŒ–ç‰ˆï¼Œå®é™…ä½¿ç”¨ECDSAï¼‰
    function verifyTEESignature(bytes32 hash, bytes memory sig) internal pure returns (bool) {
        // TEEç­¾åéªŒè¯é€»è¾‘
        return sig.length == 65; // ç®€åŒ–æ£€æŸ¥
    }
    
    // æŸ¥è¯¢ä¿¡å·æ˜¯å¦å·²éªŒè¯
    function isVerified(bytes32 _traceId) external view returns (bool) {
        return signals[_traceId].valid;
    }
    
    // ç´§æ€¥æš‚åœï¼ˆKill Switchï¼‰
    function pause() external {
        require(msg.sender == owner, "Not owner");
        // æš‚åœé€»è¾‘
    }
}
```

### 2.5 å•å±‚APIè·¯ç”±æ•´åˆ

**å…³é”®**ï¼šåœ¨å•ä¸ªNext.js API Routeä¸­ï¼Œé¡ºåºæ‰§è¡Œ**DeAIæ¨ç† â†’ å¯ä¿¡å­˜å‚¨ â†’ é“¾ä¸ŠéªŒè¯**ï¼Œä¿æŒåŸå­æ€§ã€‚

```typescript
// app/api/infer/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { DeAIInference } from '@/lib/0g/compute';
import { TrustStorage } from '@/lib/0g/storage';
import { ethers } from 'ethers';
import AuditVerifierABI from '@/contracts/AuditVerifier.json';

// ç¯å¢ƒé…ç½®ï¼ˆå•å±‚æ¶æ„ï¼Œä»…3ä¸ªå¿…éœ€å˜é‡ï¼‰
const PRIVATE_KEY = process.env.PRIVATE_KEY!;
const ZEROG_RPC = process.env.ZEROG_RPC_URL!;
const ZEROG_INDEXER = process.env.ZEROG_INDEXER_URL!;
const CONTRACT_ADDRESS = process.env.VERIFIER_CONTRACT!;

export async function POST(req: NextRequest) {
  try {
    const { symbol, factors } = await req.json();
    
    // 1. DeAIæ¨ç†ï¼ˆ0G Computeï¼‰
    const inference = new DeAIInference(PRIVATE_KEY, ZEROG_RPC);
    await inference.initialize();
    
    const { signal, requestId, provider, teeAttestation } = 
      await inference.generateSignal(factors);
    
    // 2. è¾“å…¥æŒ‡çº¹ï¼ˆæœ€å°è¯æ®é›†ï¼‰
    const inputHash = ethers.keccak256(
      ethers.toUtf8Bytes(JSON.stringify(factors))
    );
    
    // 3. å¯ä¿¡å­˜å‚¨ï¼ˆ0G Storageï¼‰
    const storage = new TrustStorage(PRIVATE_KEY, ZEROG_RPC, ZEROG_INDEXER);
    const { rootHash, txHash } = await storage.uploadStrategyEvidence({
      signal,
      inputHash,
      modelVersion: 'deepseek-v3-0g',
      timestamp: Date.now(),
      teeAttestation
    });
    
    // 4. é“¾ä¸ŠéªŒè¯ï¼ˆ0G Chainï¼‰
    const providerChain = new ethers.JsonRpcProvider(ZEROG_RPC);
    const signer = new ethers.Wallet(PRIVATE_KEY, providerChain);
    const contract = new ethers.Contract(CONTRACT_ADDRESS, AuditVerifierABI, signer);
    
    const traceId = ethers.keccak256(ethers.toUtf8Bytes(requestId));
    const tx = await contract.verifySignal(
      traceId,
      inputHash,
      signal.action,
      Math.floor(signal.confidence * 100), // è½¬ä¸ºæ•´æ•°
      rootHash,
      teeAttestation || '0x'
    );
    
    await tx.wait();
    
    // 5. è¿”å›ç»“æœï¼ˆåŒ…å«å®Œæ•´å®¡è®¡é“¾è·¯ï¼‰
    return NextResponse.json({
      success: true,
      signal: {
        symbol: signal.symbol,
        action: signal.action,
        confidence: signal.confidence,
        reasoning: `åŸºäº${signal.factors.length}ä¸ªå› å­`
      },
      provenance: {
        traceId: requestId,
        deaiProvider: provider,        // å»ä¸­å¿ƒåŒ–AIæä¾›è€…
        storageRoot: rootHash,         // 0G Storageè¯æ®æ ¹å“ˆå¸Œ
        storageTx: txHash,             // å­˜å‚¨äº¤æ˜“å“ˆå¸Œ
        chainTx: tx.hash,              // é“¾ä¸ŠéªŒè¯äº¤æ˜“
        verifiedAt: new Date().toISOString()
      }
    });
    
  } catch (error) {
    console.error('DeAIæ¨ç†å¤±è´¥:', error);
    return NextResponse.json(
      { error: 'æ¨ç†æˆ–å­˜è¯å¤±è´¥', detail: (error as Error).message },
      { status: 500 }
    );
  }
}
```

---

## ä¸‰ã€0GåŸºç¡€è®¾æ–½é…ç½®

### 3.1 ç¯å¢ƒå˜é‡ï¼ˆæç®€é…ç½®ï¼‰
```bash
# .env.local
# 0Gç½‘ç»œé…ç½®ï¼ˆGalileoæµ‹è¯•ç½‘ï¼‰
ZEROG_RPC_URL=https://evmrpc-testnet.0g.ai
ZEROG_CHAIN_ID=16602
ZEROG_INDEXER_URL=https://indexer-storage-testnet-turbo.0g.ai

# é’±åŒ…ï¼ˆç”¨äºæ”¯ä»˜DeAIæ¨ç†è´¹ç”¨å’Œå­˜å‚¨è´¹ç”¨ï¼‰
PRIVATE_KEY=0x...

# åˆçº¦åœ°å€ï¼ˆéƒ¨ç½²åå¡«å…¥ï¼‰
VERIFIER_CONTRACT=0x...

# å¯é€‰ï¼šä¸»ç½‘é…ç½®ï¼ˆç”Ÿäº§ç¯å¢ƒï¼‰
# ZEROG_RPC_URL=https://evmrpc.0g.ai
# ZEROG_CHAIN_ID=16661
```

### 3.2 ä¾èµ–å®‰è£…ï¼ˆå•å±‚TypeScriptï¼‰
```bash
# 0Gå®˜æ–¹SDK
npm install @0glabs/0g-ts-sdk @0glabs/0g-serving-broker

# EVMäº¤äº’
npm install ethers viem

# ç±»å‹å®‰å…¨
npm install zod
```

### 3.3 åˆçº¦éƒ¨ç½²è„šæœ¬ï¼ˆHardhatï¼‰
```typescript
// scripts/deploy.ts
import { ethers } from 'hardhat';

async function main() {
  const Verifier = await ethers.getContractFactory('StratTrustVerifier');
  const verifier = await Verifier.deploy();
  await verifier.waitForDeployment();
  
  console.log('éªŒè¯åˆçº¦éƒ¨ç½²è‡³:', await verifier.getAddress());
}

main().catch(console.error);
```

---

## å››ã€DeAIå¯ä¿¡æµç¨‹è¯¦è§£

### 4.1 å®Œæ•´æ•°æ®æµï¼ˆå¯è¿½æº¯ï¼‰

```
ç”¨æˆ·è¯·æ±‚
   â†“
[Next.js API Route]
   â†“
1. DeAIæ¨ç† (0G Compute)
   - è°ƒç”¨ DeepSeek V3 (å»ä¸­å¿ƒåŒ–èŠ‚ç‚¹)
   - ç”Ÿæˆä¿¡å·: BUY PEPE 0.85
   - è·å¾— TEE Attestation (å¯é€‰)
   â†“
2. è¯æ®æ„å»º
   - è¾“å…¥å› å­å“ˆå¸Œ: 0xabc...
   - è¾“å‡ºä¿¡å·æ‘˜è¦
   - æ—¶é—´æˆ³ + Nonce
   â†“
3. å¯ä¿¡å­˜å‚¨ (0G Storage)
   - ç”Ÿæˆ Merkle Tree
   - ä¸Šä¼ è‡³0G Storageç½‘ç»œ
   - è·å¾— Root Hash: 0xdef...
   â†“
4. é“¾ä¸ŠéªŒè¯ (0G Chain)
   - è°ƒç”¨ AuditVerifier.verifySignal()
   - è®°å½•: inputHash + rootHash + action
   - è§¦å‘ SignalVerified äº‹ä»¶
   â†“
è¿”å›ç”¨æˆ·
{
  signal: {action, confidence},
  provenance: {
    storageRoot: "0xdef...",    // å¯éªŒè¯å­˜å‚¨ä½ç½®
    chainTx: "0x123...",        // é“¾ä¸ŠéªŒè¯äº¤æ˜“
    deaiProvider: "0xNode..."   // å»ä¸­å¿ƒåŒ–AIèŠ‚ç‚¹
  }
}
```

### 4.2 å®¡è®¡è¿½æº¯æŸ¥è¯¢

ç”¨æˆ·å¯é€šè¿‡**traceId**åœ¨ä»»æ„æ—¶é—´ç‚¹éªŒè¯ç­–ç•¥çœŸå®æ€§ï¼š

```typescript
// å®¡è®¡æŸ¥è¯¢API
export async function auditQuery(traceId: string) {
  // 1. æŸ¥è¯¢é“¾ä¸Šè®°å½•
  const contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, provider);
  const onChainData = await contract.signals(traceId);
  
  // 2. ä»0G Storageä¸‹è½½åŸå§‹è¯æ®
  const storage = new TrustStorage(privateKey, rpc, indexer);
  const isValid = await storage.verifyEvidence(
    onChainData.storageRoot,
    { inputHash: onChainData.inputHash }
  );
  
  return {
    verified: isValid && onChainData.valid,
    timestamp: onChainData.timestamp,
    storageRoot: onChainData.storageRoot,
    action: onChainData.action
  };
}
```

---

## äº”ã€æˆæœ¬ä¸æ€§èƒ½ä¼˜åŒ–

### 5.1 æˆæœ¬ç»“æ„ï¼ˆ0Gä¼˜åŠ¿ï¼‰
| æ“ä½œ | ä¼ ç»Ÿæ–¹æ¡ˆ | 0G DeAIæ–¹æ¡ˆ | èŠ‚çœ |
|-----|---------|------------|-----|
| AIæ¨ç† | OpenAI API $0.01/æ¬¡ | 0G Computeå¾®æ”¯ä»˜ ~$0.005/æ¬¡ | 50% |
| æ•°æ®å­˜å‚¨ | AWS S3 $0.023/GB | 0G Storage ~$0.001/GB | 95% |
| é“¾ä¸Šå­˜è¯ | Ethereum $5-50/tx | 0G Chain <$0.01/tx | 99% |
| éªŒè¯å»¶è¿Ÿ | ä¸­å¿ƒåŒ–API 200ms | 0G DeAI 500-800ms | å¯æ¥å— |

### 5.2 æ‰¹å¤„ç†ä¼˜åŒ–ï¼ˆMerkleæ‰¹é‡ä¸Šé“¾ï¼‰
```typescript
// æ‰¹é‡å®¡è®¡ï¼ˆé™ä½æˆæœ¬ï¼‰
export async function batchAudit() {
  const batch = [];
  
  // æ”¶é›†1å°æ—¶å†…çš„ä¿¡å·
  for (let i = 0; i < 100; i++) {
    batch.push(await generateSignal());
  }
  
  // ä¸€æ¬¡æ€§ä¸Šä¼ Merkle Rootï¼ˆè€Œé100æ¬¡å•ç‹¬ä¸Šä¼ ï¼‰
  const { rootHash } = await storage.batchUploadEvidence(batch);
  
  // é“¾ä¸Šä»…è®°å½•Rootï¼ˆ1ç¬”äº¤æ˜“æ›¿ä»£100ç¬”ï¼‰
  await contract.verifyBatch(rootHash, batch.length);
}
```

---

## å…­ã€ä¸å‰æœŸè§„èŒƒçš„å…¼å®¹æ€§

**ç¬¦åˆ"é©¬æ–¯å…‹å¼æç®€æ¶æ„"**ï¼š
- âœ… **å•è¯­è¨€**: çº¯TypeScriptï¼ˆ0G SDKå‡ä¸ºTS/JSï¼‰
- âœ… **é›¶å¾®æœåŠ¡**: æ‰€æœ‰0Gäº¤äº’åœ¨Next.js API Routeä¸­åŸå­å®Œæˆ
- âœ… **AIè£¸è°ƒ**: é€šè¿‡HTTPè°ƒç”¨0G Computeï¼ˆè™½ç»Brokerï¼Œä½†ä»ä¸ºHTTPå±‚ï¼‰
- âœ… **å•å±‚å­˜å‚¨**: PostgreSQLä»…åšç´¢å¼•ç¼“å­˜ï¼Œä¸»æ•°æ®åœ¨0G Storage
- âœ… **æ— Docker**: Vercelç›´æ¥éƒ¨ç½²ï¼Œä½¿ç”¨Serverless Function

**0Gç‰¹æœ‰å¢å¼º**ï¼š
- ğŸš€ **å»ä¸­å¿ƒåŒ–AI**: æŠ—å®¡æŸ¥ï¼Œæ— å•ç‚¹æ•…éšœ
- ğŸš€ **æ°¸ä¹…å­˜å‚¨**: ç­–ç•¥å†å²ä¸å¯ç¯¡æ”¹ï¼ˆåŒºåˆ«äºä¼ ç»Ÿäº‘å­˜å‚¨ï¼‰
- ğŸš€ **é“¾ä¸ŠéªŒè¯**: TEE + Merkle åŒé‡å¯ä¿¡ä¿éšœ

---

## ä¸ƒã€ç«‹å³æ‰§è¡Œæ¸…å•

### ä»Šæ—¥å®Œæˆï¼ˆDeAIåŸºç¡€è®¾æ–½ï¼‰ï¼š
1. **æ³¨å†Œ0G**ï¼š
   - è®¿é—® https://faucet.0g.ai è·å–æµ‹è¯•å¸
   - è®°å½•ç§é’¥å’ŒRPCé…ç½®

2. **å®‰è£…ä¾èµ–**ï¼š
   ```bash
   npm install @0glabs/0g-ts-sdk @0glabs/0g-serving-broker ethers zod
   ```

3. **éƒ¨ç½²éªŒè¯åˆçº¦**ï¼š
   ```bash
   npx hardhat run scripts/deploy.ts --network 0g-testnet
   ```

4. **å®ç°æ ¸å¿ƒAPI**ï¼š
   - å¤åˆ¶ `lib/0g/compute.ts`ï¼ˆDeAIæ¨ç†ï¼‰
   - å¤åˆ¶ `lib/0g/storage.ts`ï¼ˆå¯ä¿¡å­˜å‚¨ï¼‰
   - å¤åˆ¶ `app/api/infer/route.ts`ï¼ˆæ•´åˆè·¯ç”±ï¼‰

5. **æµ‹è¯•éªŒè¯**ï¼š
   ```bash
   curl -X POST http://localhost:3000/api/infer \
     -H "Content-Type: application/json" \
     -d '{"symbol":"PEPE","factors":{"oif":0.5,"sentiment":0.8}}'
   ```

**é¢„æœŸç»“æœ**ï¼š
- è¿”å›é€‰å¸ä¿¡å·ï¼ˆBUY/SELL/HOLDï¼‰
- åŒ…å« `provenance.storageRoot`ï¼ˆ0Gå­˜å‚¨è¯æ˜ï¼‰
- åŒ…å« `provenance.chainTx`ï¼ˆé“¾ä¸ŠéªŒè¯äº¤æ˜“å“ˆå¸Œï¼‰

è¿™æ˜¯**çœŸæ­£çš„DeAIæ¶æ„**ï¼šå»ä¸­å¿ƒåŒ–æ¨ç†ã€æ°¸ä¹…å­˜å‚¨ã€é“¾ä¸ŠéªŒè¯ï¼Œä¸”ä¿æŒå•å±‚æç®€ã€‚